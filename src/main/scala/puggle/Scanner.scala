package puggle

import scala.collection.mutable.ListBuffer

class Scanner(src: String) {

  private var cursor = -1
  private var line = 0

  /**
   * @return Scans the given string of source code into a List of Tokens.
   */
  def scan(): List[Token] =
    val tokenBuffer: ListBuffer[Token] = ListBuffer()

    println("Scanning Source...")
    // create a list of tokens by calling nextToken until EOF is hit
    var currentToken = nextToken()

    while currentToken!= EOF do
      tokenBuffer += currentToken
      currentToken = nextToken()

    tokenBuffer += currentToken
    println(s"Lines: ${line + 1}")
    tokenBuffer.to(List)

  /**
   * @return The next token in the source string.
   */
  private def nextToken(): Token =
    nextChar match
      case Some(c) => getToken(c)
      case None => EOF

  /**
   * @return Advances to the next char in the source string.
   */
  private def nextChar: Option[Char] =
    cursor += 1
    if cursor < src.length then
      Some(src.charAt(cursor)) else None

  /**
   * @return Peaks at the next char in the source string without advancing
   */
  private def peekNext(): Option[Char] =
    if cursor + 1 < src.length then
      Some(src.charAt(cursor + 1)) else None

  /**
   * @param c The character in the source at the cursor.
   * @return A single token generated by lexeme starting at current.
   */
  private def getToken(c: Char): Token = c match
    case '(' => LEFT_PAREN
    case ')' => RIGHT_PAREN
    case '{' => LEFT_BRACE
    case '}' => RIGHT_BRACE
    case ',' => COMMA
    case '.' => DOT
    case ';' => SEMICOLON
    case '+' => PLUS
    case '-' => MINUS
    case '*' => MULTIPLY
    case '/' => if matchNext('/') then comment() else DIVIDE
    case '=' => if matchNext('=') then EQUAL else ASSIGN
    case '>' => if matchNext('=') then GREATER_EQUAL else GREATER
    case '<' => if matchNext('=') then LESSER_EQUAL else LESSER
    case '!' => if matchNext('=') then NOT_EQUAL else NOT
    case '"' => string()
    case ' ' | '\r' | '\t' => nextToken()
    case '\n' => line += 1; nextToken()
    case _ => Error.report(UnexpectedCharacter(c, line)); nextToken()

  /**
   * @return The token after the comment.
   */
  private def comment(): Token =
    while peekNext().isDefined && peekNext().get != '\n' do
      nextChar
    nextToken()

  /**
   * @return A string token.
   */
  private def string(): Token =
    val begin = cursor

    while peekNext().isDefined && peekNext().get != '"' do
      if peekNext().get == '\n' then line += 1
      nextChar

    if cursor == src.length then
      Error.report(UnterminatedString(line))

    StringLiteral(src.substring(begin + 1, cursor - 1))

  /**
   * @param expected The next expected character.
   * @return true if the next char is expected.
   */
  private def matchNext(expected: Char) = peekNext() match
    case Some(c) if c == expected => nextChar; true
    case _ => false
}