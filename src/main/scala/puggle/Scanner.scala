package puggle

import scala.annotation.tailrec
import scala.collection.mutable.ListBuffer

class Scanner(src: String) {

  private var cursor = -1
  private var line = 0

  /**
   * @return Scans the given string of source code into a List of Tokens.
   */
  def scan(): List[Token] = getTokens().reverse

  /**
   * @return List of tokens generate by source
   */
  @tailrec
  private def getTokens(list: List[Token] = Nil): List[Token] = {
    val token = nextToken()
    val result = token :: list
    if (token != EOF) getTokens(result) else result
  }

  /**
   * @return The next token in the source string.
   */
  private def nextToken(): Token = nextChar match
      case Some(c) => scanToken(c)
      case None => EOF

  /**
   * @return Advances to the next char in the source string.
   */
  private def nextChar: Option[Char] =
    cursor += 1
    if cursor < src.length then
      Some(src.charAt(cursor))
    else None

  /**
   * @return Peaks at the next char in the source string without advancing
   */
  private def peekNext(): Option[Char] =
    if cursor + 1 < src.length then
      Some(src.charAt(cursor + 1))
    else None

  /**
   * @param c The character in the source at the cursor.
   * @return A single token generated by lexeme starting at current.
   */
  private def scanToken(c: Char): Token = c match
    case '(' => LEFT_PAREN
    case ')' => RIGHT_PAREN
    case '{' => LEFT_BRACE
    case '}' => RIGHT_BRACE
    case ',' => COMMA
    case '.' => DOT
    case ';' => SEMICOLON
    case '+' => PLUS
    case '-' => MINUS
    case '*' => MULTIPLY
    case '/' => if matchNext('/') then comment() else DIVIDE
    case '=' => if matchNext('=') then EQUAL else ASSIGN
    case '>' => if matchNext('=') then GREATER_EQUAL else GREATER
    case '<' => if matchNext('=') then LESSER_EQUAL else LESSER
    case '!' => if matchNext('=') then NOT_EQUAL else NOT
    case '"' => string()
    case ' ' | '\r' | '\t' => nextToken()
    case '\n' => line += 1; nextToken()
    case _ => Error.report(UnexpectedCharacter(c, line)); nextToken()

  /**
   * @param expected The next expected character.
   * @return true if the next char is expected.
   */
  private def matchNext(expected: Char) = peekNext() match
    case Some(c) if c == expected => nextChar; true
    case _ => false

  /**
   * @return Eats a line, returns the next token.
   */
  private def comment(): Token =
    while peekNext().isDefined && peekNext().get != '\n' do
      nextChar
    nextToken()

  /**
   * @return A string token.
   */
  private def string(): Token =
    val begin = cursor

    // Consume chars until end of string or end of file.
    while peekNext().isDefined && peekNext().get != '"' do
      if peekNext().get == '\n' then line += 1
      nextChar

    // Consume closing " if it exits, otherwise it don't matter baby
    nextChar

    // Check for unterminated string
    if cursor == src.length then
      Error.report(UnterminatedString(line))

    StringLiteral(src.substring(begin + 1, cursor))
}